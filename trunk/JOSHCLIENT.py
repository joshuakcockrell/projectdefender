import os
import pygame
from pygame.locals import *
from twisted.spread import pb
from twisted.internet.selectreactor import SelectReactor
from twisted.internet.main import installReactor

from weakref import WeakKeyDictionary


class Event():
    '''
    superclass for events
    '''
    def __init__(self):
        self.name = 'Default Event'

class TickEvent(Event):
    '''
    frame rate tick
    '''
    def __init__(self):
        self.name = 'Tick Event'

class ProgramQuitEvent(Event):
    '''
    when we quit the program
    '''
    def __init__(self):
        self.name = 'Program Quit Event'



class UserKeyboardInputEvent(Event):
    '''
    When the user presses keyboard keys
    generated by the KeyboardController
    Not sent over the network
    '''
    def __init__(self, keyboard_input):  
        self.name = 'User Keyboard Input Event'
        self.keyboard_input = keyboard_input

class GameStartRequestEvent(Event):
    def __init__(self):
        self.name = 'Game Start Request Event'

class GameStartedEvent(Event):
    '''
    the game has started
    '''
    def __init__(self, game):
        self.name = 'Game Started'
        self.game = game

class CharacterMoveRequestEvent(Event):
    '''
    when a character moves in a direction
    '''
    def __init__(self, character_id, direction):
        self.name = 'Character Move Request Event'
        self.character_id = character_id
        self.direction = direction

class CharacterMoveEvent(Event):
    '''
    when a character moves
    '''
    def __init__(self, character):
        self.name = 'Character Move Event'
        self.character = character

class MouseClickEvent(Event):
    '''
    when a user clicks down on the mouse
    '''
    def __init__(self, clickPosition):
        self.name = 'Mouse Click Event'
        self.position = clickPosition

class ServerConnectEvent(Event):
    def __init__(self, serverReference):
        self.name = 'Server Connect Event'
        self.server = serverReference


class ClientConnectEvent(Event):
    def __init__(self, client):
        self.name = 'Client Connect Event'
        self.client = client



class Character():
    '''the character object'''
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.register_listener(self)

        self.positionX = None
        self.positionY = None
        self.position = (self.positionX, self.positionY)
        self.speed = 5
        self.state = 'INACTIVE'

    def _move(self, direction):
        if self.state == 'INACTIVE':
            return
        self.positionX += self.speed
        newEvent = CharacterMoveEvent(self)
        self.eventManager.post(newEvent)

    def _spawn(self, position):
        self.position = position
        self.state = 'ACTIVE'
        newEvent = CharacterSpawnEvent(self)
        self.eventManager.post(newEvent)

    def notify(self, event):
        if isinstance(event, GameStartedEvent):
            self._spawn((100,100))

        elif isinstance(event, CharacterMoveRequest):
            self._move(event.direction)



copyable_events = {}

server_to_client_events = []
client_to_server_events = []

######################## Stuff from network.py
def MixInClass(origClass, addClass):
    if addClass not in origClass.__bases__:
        origClass.__bases__ += (addClass,)

def MixInCopyClasses(someClass):
    MixInClass(someClass, pb.Copyable)
    MixInClass(someClass, pb.RemoteCopy)

class CopyableCharacter():
    def get_state_to_copy(self):
        dictionary = self.__dict__.copy()
        del d['eventManager']
        dictionary['position'] = id(self.position)
        return dictionary

    def set_copyable_state(self, state_dictionary, object_registry):
        needed_object_ids = []
        sucess = True
        if not object_registry.has_key(state_dictionary['position']):
            needed_object_ids.append(state_dictionary['position'])
            sucess = False
        else:
            self.position = object_registry[state_dictionary['position']]
        return [sucess, needed_object_ids]

MixInClass(Character, CopyableCharacter)


# mixing in the copy classes here
#client to server
MixInCopyClasses(ProgramQuitEvent)
pb.setUnjellyableForClass(ProgramQuitEvent, ProgramQuitEvent)
client_to_server_events.append(ProgramQuitEvent)

#client to server
MixInCopyClasses(GameStartRequestEvent)
pb.setUnjellyableForClass(GameStartRequestEvent, GameStartRequestEvent)
client_to_server_events.append(GameStartRequestEvent)

#client to server
MixInCopyClasses(CharacterMoveRequestEvent)
pb.setUnjellyableForClass(CharacterMoveRequestEvent,CharacterMoveRequestEvent)
client_to_server_events.append(CharacterMoveRequestEvent)

class CopyableGameStartedEvent(pb.Copyable, pb.RemoteCopy):
    '''server to client only'''
    def __init__(self, event, object_registry):
        self.name = 'Copyable Game Started Event'
        self.game_id = id(event.game)
        object_registry[self.game_id] = event.game

pb.setUnjellyableForClass(CopyableGameStartedEvent, CopyableGameStartedEvent)
server_to_client_events.append(CopyableGameStartedEvent)

class CopyableCompleteGameStateEvent(pb.Copyable, pb.RemoteCopy):
    '''server to client only'''
    def __init__(self, event, object_registry):
        self.name = 'Copyable Complete Game State Event'
        self.game_state = event.game_state

pb.setUnjellyableForClass(CopyableCompleteGameStateEvent, CopyableCompleteGameStateEvent)
server_to_client_events.append(CopyableCompleteGameStateEvent)

class CopyableCharacterMoveEvent(pb.Copyable, pb.RemoteCopy):
    def __init__(self, event, object_registry):
        print 'CREATING AN EVENT DUDEEEEEEEEEEEEEEEEEEEE'
        print event
        self.name = 'Copyable Character Move Event'
        self.character_id = id(event.character)
        object_registry[self.character_id] = event.character
        self.position = event.position # position to move to

pb.setUnjellyableForClass(CopyableCharacterMoveEvent, CopyableCharacterMoveEvent)
server_to_client_events.append(CopyableCharacterMoveEvent)

class CopyableNewCharacterSpriteEvent(pb.Copyable, pb.RemoteCopy):
    '''We dont send the actual character'''
    def __init__(self, event, object_registry):
        self.name = 'Copyable New Character Sprite Event'
        self.character_id = event.character_id
        object_registry[self.character_id] = event.character
        self.character_position = event.character_position

pb.setUnjellyableForClass(CopyableNewCharacterSpriteEvent, CopyableNewCharacterSpriteEvent)
server_to_client_events.append(CopyableNewCharacterSpriteEvent)

class CopyableCharacterMoveRequestEvent(pb.Copyable, pb.RemoteCopy):
    def __init__(self, event, object_registry):
        self.name = 'Copyable Character Move Request Event'
        self.character_id = event.character_id
        self.direction = event.direction

pb.setUnjellyableForClass(CopyableCharacterMoveRequestEvent, CopyableCharacterMoveRequestEvent)
server_to_client_events.append(CopyableCharacterMoveRequestEvent)

# add the keys and classes to the copyable_events dictionary
copyable_events['CopyableGameStartedEvent'] = CopyableGameStartedEvent
copyable_events['CopyableCompleteGameStateEvent'] = CopyableCompleteGameStateEvent
copyable_events['CopyableCharacterMoveEvent'] = CopyableCharacterMoveEvent
copyable_events['CopyableNewCharacterSpriteEvent'] = CopyableNewCharacterSpriteEvent
copyable_events['CopyableCharacterMoveRequestEvent'] = CopyableCharacterMoveRequestEvent


class EventManager():
    '''super class event manager'''
    def __init__(self):
        self.listeners = WeakKeyDictionary()
        self.event_queue = []

    def register_listener(self, listener):
        self.listeners[listener] = True

    def unregister_listener(self, listener):
        if listener in self.listeners:
            del self.listeners[listener]
    def post(self, event):
        self.event_queue.append(event)
        if isinstance(event, TickEvent):
            self._process_event_queue()
        else:
            pass

    def _process_event_queue(self):
        # goes through all the events and sends them to the listeners
        event_number = 0
        while event_number < len(self.event_queue):
            event = self.event_queue[event_number]
            for listener in self.listeners:
                listener.notify(event)
            event_number += 1
        # empty the queue
        self.event_queue = []

       
######################################

        
class NetworkServerView(pb.Root):
    ''' Used to send events to the Server'''

    def __init__(self, eventManager, object_registry):
        self.eventManager = eventManager
        self.eventManager.register_listener(self)

        self.pbClientFactory = pb.PBClientFactory()
        self.state = 'PREPARING'
        self.reactor = None
        self.server = None

        self.object_registry = object_registry

    def attempt_connection(self):
        print 'Attempting connection...'
        self.state = 'CONNECTING'
        if self.reactor:
            self.reactor.stop()
            self.pump_reactor()
        else:
            self.reactor = SelectReactor()
            installReactor(self.reactor)
            connection = self.reactor.connectTCP('localhost', 24100, self.pbClientFactory)
            deferred = self.pbClientFactory.getRootObject()
            deferred.addCallback(self.connected)
            deferred.addErrback(self.connect_failed)
            self.reactor.startRunning()

    def disconnect(self):
        print 'disconnecting...'
        if not self.reactor:
            return
        print 'stopping the client reactor...'
        self.reactor.stop()
        self.pump_reactor()
        self.state = 'DISCONNECTING'

    def connected(self, server):
        print '...connected!'
        self.server = server
        self.state = 'CONNECTED'
        newEvent = ServerConnectEvent(server)
        self.eventManager.post(newEvent)

    def connect_failed(self, server):
        print '...Connection failed'
        self.state = 'DISCONNECTED'

    def pump_reactor(self):
        self.reactor.runUntilCurrent()
        self.reactor.doIteration(False)
        
    def notify(self, event):
        if isinstance(event, TickEvent):
            if self.state == 'PREPARING':
                self.attempt_connection()
            elif self.state in ['CONNECTED', 'DISCONNECTING', 'CONNECTING']:
                self.pump_reactor()
            return
                
        if isinstance(event, ProgramQuitEvent):
            self.disconnect()
            return

        if not isinstance(event, pb.Copyable):
            event_name = event.__class__.__name__
            copyable_class_name = 'Copyable' + event_name
            if not copyable_class_name in copyable_events:
                return
            copyableClass = copyable_events[copyable_class_name]
            event = copyableClass(event, self.object_registry)

        if event.__class__ not in client_to_server_events:
            return

        if self.server:
            #print 'Client sending: ', str(event.name)
            remoteCall = self.server.callRemote('EventOverNetwork', event)

        else:
            print 'cannot send while disconnected:', str(event)


class NetworkServerController(pb.Referenceable):
    '''Recieves events from the Server'''
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.register_listener(self)

    def remote_RecieveEvent(self, event):
        # the server calls this function to send an event
        #print 'Event recieved from server:', str(event.name)
        self.eventManager.post(event)
        return True

    def notify(self, event):
        if isinstance(event, ServerConnectEvent):
            event.server.callRemote('ClientConnect', self)

class CPUSpinnerController():
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.register_listener(self)
        self.clock = pygame.time.Clock() # create a clock
        self.FPS = 40

        self.running = True

    def run(self):
        while self.running:
            pygame.display.set_caption(str(self.clock.get_fps()))
            self.clock.tick(self.FPS)
            newEvent = TickEvent()
            self.eventManager.post(newEvent)

    def notify(self, event):
        if isinstance(event, ProgramQuitEvent):
            self.running = False

class KeyboardController():
    ''' gets user input from the mouse and keyboard'''
    def __init__(self, eventManager):
        self.eventManager = eventManager
        self.eventManager.register_listener(self)

    def notify(self, event):
        if isinstance(event, TickEvent):
            #go through the user input
            for event in pygame.event.get():
                newEvent = None
                if event.type == QUIT:
                    newEvent = ProgramQuitEvent()
                elif event.type == KEYDOWN:
                    if event.key in [pygame.K_ESCAPE]:
                        newEvent = ProgramQuitEvent()
                if newEvent:
                    self.eventManager.post(newEvent)

            #getting arrow key movement
            pressed = pygame.key.get_pressed()
            directionX = pressed[K_d] - pressed[K_a]
            directionY = pressed[K_s] - pressed[K_w]
            
            # ready the direction details
            text_directionX = ''
            text_directionY = ''
            text_direction = ''
            
            if directionX == -1:
                text_directionX = 'LEFT'
            elif directionX == 1:
                text_directionX = 'RIGHT'
            if directionY == -1:
                text_directionY = 'UP'
            elif directionY == 1:
                text_directionY = 'DOWN'
                
            text_direction = text_directionX + text_directionY # put direction into a string
            if text_direction:# if the user pressed a direction
                newEvent = UserKeyboardInputEvent(text_direction)
                self.eventManager.post(newEvent)

class CharacterSprite(pygame.sprite.Sprite):
    def __init__(self, character_id, position, group=None):
        pygame.sprite.Sprite.__init__(self, group)
        self.id = character_id
        
        self.image = pygame.image.load(os.path.join('resources','character.png'))
        self.image.convert()
        self.rect = self.image.get_rect()

        self.position = None # position to move to during update
        self.set_position(position)

    def set_position(self, position):
        self.position = position
    def update(self):
        self.rect.center = self.position


class PygameView():
    def __init__(self, eventManager, object_registry):
        self.eventManager = eventManager
        self.eventManager.register_listener(self)

        pygame.init()
        self.screen = pygame.display.set_mode((800, 640))
        pygame.display.set_caption('Dude! if you can see this, its working!!!')
        self.background = pygame.Surface(self.screen.get_size())
        self.background.fill((120,235,22))
        self.screen.blit(self.background, (0,0))
        pygame.display.flip()
        self.clock = pygame.time.Clock()
        
        self.user_controlled_character = None
        self.game_state_requested = True # we have not requested the game state

        self.object_registry = object_registry # holds the object ids and their respective objects

        self.sprites_dictionary = {} # holds object names, and their classes
        self.sprites_dictionary['CHARACTER'] = self._create_new_character_sprite # character index
    
        #create object groups
        self.character_sprites = pygame.sprite.RenderUpdates()

    def _process_game_state(self, game_state):
        # recieved a list when the client connects to get the game objects
        # example of game state list
        # [['OBJECT NAME', id, [position]], object2, object3
        # [['CHARACTER', 19376408, [300, 300]], ['CHARACTER', 19377248, [300, 300]]]
        for game_object in game_state:
            object_name = game_object[0]
            object_id = game_object[1]
            object_position = game_object[2]

            object_class = self.sprites_dictionary[object_name]
            object_is_user_controlled = False
            object_class(object_id, object_position, object_is_user_controlled) # create an instance of the object
            

    def _user_wants_to_move_character(self, keyboard_input):
        ''' When the user presses w,a,s, or d:
        aka: when a User Keyboard Input Event is generated
        PygameView.notify() calls this function
        each character sends a move request and
        sends their id
        '''
        if self.user_controlled_character:
            moving_character = self.user_controlled_character
            newEvent = CharacterMoveRequestEvent(moving_character.id, keyboard_input)
            self.eventManager.post(newEvent)
            
    def move_character(self, character_id, position):
        character_to_move = self.object_registry[character_id]
        character_to_move.set_position(position)


    def get_character_sprite(self, character):
        for c in self.character_sprites:
            return c

    def _create_new_character_sprite(self, character_id, position, object_is_user_controlled):
        #create the new sprite
        newCharacterSprite = CharacterSprite(character_id, position, self.character_sprites)
        #assign the registry slot to the character sprite
        self.object_registry[character_id] = newCharacterSprite
        if object_is_user_controlled:
            if not self.user_controlled_character:
                print 'CHECKING IF HAS ONE'
                print self.user_controlled_character
                self.user_controlled_character = newCharacterSprite

    def notify(self, event):
        if isinstance(event, TickEvent):
            self.screen.blit(self.background, (0,0))
            self.character_sprites.update()

            self.character_sprites.draw(self.screen)

            pygame.display.flip()

        elif event.name == 'Copyable Complete Game State Event':
            if self.game_state_requested:
                self._process_game_state(event.game_state)
                self.game_state_requested = False

        elif event.name == 'Copyable New Character Sprite Event':
            character_id = event.character_id
            character_position = event.character_position
            object_is_user_controlled = True
            self._create_new_character_sprite(character_id, character_position, object_is_user_controlled)

        elif event.name == 'User Keyboard Input Event':
            if event.keyboard_input in ['UP', 'DOWN', 'LEFT', 'RIGHT',
                                        'LEFTUP', 'RIGHTUP', 'LEFTDOWN',
                                        'RIGHTDOWN']:
                self._user_wants_to_move_character(event.keyboard_input)

        elif isinstance(event, CopyableCharacterMoveEvent):
            self.move_character(event.character_id, event.position)

            

def main():
    print '############################################'
    print '##### Starting Project Defender Client #####'
    print '############################################'
    print 'Loading...'

    eventManager = EventManager()
    object_registry = {}

    keyboardController = KeyboardController(eventManager)
    spinnerController = CPUSpinnerController(eventManager)

    pygameView = PygameView(eventManager, object_registry)

    serverController = NetworkServerController(eventManager)
    serverView = NetworkServerView(eventManager, object_registry)

    print '...Loading Complete!'
    print 'Running Program...'
    spinnerController.run()
    print '...running complete'

if __name__ == '__main__':
    main()
    pygame.quit()
